import React, { useRef, useEffect, useMemo, useState } from "react";
import maplibregl from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";

const PIN_SOURCE_ID = "entitled-persons";
const PIN_CIRCLE_LAYER_ID = `${PIN_SOURCE_ID}-circles`;
const PIN_LABEL_LAYER_ID = `${PIN_SOURCE_ID}-labels`;
const S3_SOURCE_ID = "fake-s3-features";

// Helper function that figures out how far to zoom to show all data
const computeBoundsFromGeoJson = (geojson) => {
  if (!geojson) return null;

  const bounds = new maplibregl.LngLatBounds();
  let hasCoordinates = false;

  const extendBounds = (coords) => {
    if (!Array.isArray(coords)) return;

    if (coords.length >= 2 && typeof coords[0] === "number" && typeof coords[1] === "number") {
      bounds.extend(coords);
      hasCoordinates = true;
      return;
    }

    coords.forEach(extendBounds);
  };

  const walkGeometry = (geometry) => {
    if (!geometry) return;
    const { type, coordinates, geometries } = geometry;

    if (type === "GeometryCollection" && Array.isArray(geometries)) {
      geometries.forEach(walkGeometry);
      return;
    }

    extendBounds(coordinates);
  };

  const walkFeature = (feature) => {
    if (!feature) return;

    if (feature.type === "Feature") {
      walkGeometry(feature.geometry);
      return;
    }

    // Handles bare geometry objects
    if (feature.type && feature.coordinates) {
      walkGeometry(feature);
    }
  };

  if (geojson.type === "FeatureCollection" && Array.isArray(geojson.features)) {
    geojson.features.forEach(walkFeature);
  } else if (geojson.type === "Feature") {
    walkFeature(geojson);
  } else if (geojson.type) {
    walkGeometry(geojson);
  } else if (Array.isArray(geojson)) {
    extendBounds(geojson);
  }

  return hasCoordinates ? bounds : null;
};

const normalizePinLocations = (locations = []) => {
  const features = locations
    .map((location) => {
      const longitude = Number(
        typeof location?.longitude !== "undefined"
          ? location.longitude
          : location?.coordinates?.longitude,
      );
      const latitude = Number(
        typeof location?.latitude !== "undefined"
          ? location.latitude
          : location?.coordinates?.latitude,
      );

      if (!Number.isFinite(longitude) || !Number.isFinite(latitude)) {
        return null;
      }

      return {
        type: "Feature",
        id: location?.id,
        properties: {
          name: location?.name ?? "",
          description: location?.description ?? "",
          to_evacuate: location?.to_evacuate ?? false,
          timestamp: location?.timestamp ?? null,
        },
        geometry: {
          type: "Point",
          coordinates: [longitude, latitude],
        },
      };
    })
    .filter(Boolean);

  return {
    type: "FeatureCollection",
    features,
  };
};

const fitMapToBounds = (map, ...boundsList) => {
  const validBounds = boundsList.filter(Boolean);
  if (!map || validBounds.length === 0) return;

  const [firstBound, ...rest] = validBounds;
  const combinedBounds = new maplibregl.LngLatBounds(firstBound.getSouthWest(), firstBound.getNorthEast());
  rest.forEach((bound) => {
    combinedBounds.extend(bound.getSouthWest());
    combinedBounds.extend(bound.getNorthEast());
  });

  map.fitBounds(combinedBounds, { padding: 40, maxZoom: 13, duration: 800 });
};

// Defines the main MapLibreMap React component
export default function MapLibreMap({
  apiKey,
  region = "eu-west-2",
  styleName = "Standard",
  colorScheme = "Light",
  center = [-123.115898, 49.295868],
  zoom = 11,
  height = "100vh",
  geoJsonUrl,
}) {
  const [pinLocations, setPinLocations] = useState([]);
  const pinsGeoJson = useMemo(() => normalizePinLocations(pinLocations), [pinLocations]);
  const pinBounds = useMemo(() => computeBoundsFromGeoJson(pinsGeoJson), [pinsGeoJson]);

  // Keeps references to the map container and map object
  const mapContainerRef = useRef(null);
  const mapRef = useRef(null);
  const s3BoundsRef = useRef(null);
  const pinBoundsRef = useRef(pinBounds);

  useEffect(() => {
    pinBoundsRef.current = pinBounds;
  }, [pinBounds]);

  // Creates the base map when the component appears
  useEffect(() => {
    if (!mapContainerRef.current) return;

    // Initialises the map
    const map = new maplibregl.Map({
      container: mapContainerRef.current,
      style: `https://maps.geo.${region}.amazonaws.com/v2/styles/${styleName}/descriptor?key=${apiKey}&color-scheme=${colorScheme}`,
      center,
      zoom,
    });

    // Adds zoom and rotation controls to the map.
    map.addControl(new maplibregl.NavigationControl(), "top-left");
    mapRef.current = map;

    // Cleans up on unmount
    return () => {
      mapRef.current = null;
      map.remove();
    };
  }, [apiKey, region, styleName, colorScheme, center, zoom]);

  // Fetch entitled-person pin locations from remote endpoint
  useEffect(() => {
    const abortController = new AbortController();
    const loadPinLocations = async () => {
      try {
        const response = await fetch("https://ksip4rkha0.execute-api.eu-west-2.amazonaws.com/entitled-persons", {
          signal: abortController.signal,
        });
        if (!response.ok) {
          throw new Error(`Pin locations fetch failed: ${response.status} ${response.statusText}`);
        }
        const payload = await response.json();
        const locations = Array.isArray(payload) ? payload : (Array.isArray(payload?.value) ? payload.value : []);
        setPinLocations(locations);
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error("Failed to load pin locations:", error);
        }
      }
    };

    loadPinLocations();

    return () => {
      abortController.abort();
    };
  }, []);

  // Fetches GeoJSON, draws polygons/points, adjusts view
  useEffect(() => {
    const map = mapRef.current;
    if (!map || !geoJsonUrl) return;

    const polygonFillLayerId = `${S3_SOURCE_ID}-polygon-fill`;
    const polygonOutlineLayerId = `${S3_SOURCE_ID}-polygon-outline`;
    const pointLayerId = `${S3_SOURCE_ID}-points`;
    const abortController = new AbortController();

    // Function that fetches the GeoJSON and adds it to the map
    const addGeoJsonToMap = async () => {
      try {
        // Fetches the GeoJSON file from the provided URL
        const response = await fetch(geoJsonUrl, {
          signal: abortController.signal,
        });
        if (!response.ok) {
          throw new Error(`GeoJSON fetch failed: ${response.status} ${response.statusText}`);
        }
        const geojson = await response.json();

        // Removes existing layers and source if they exist
        if (map.getLayer(pointLayerId)) map.removeLayer(pointLayerId);
        if (map.getLayer(polygonOutlineLayerId)) map.removeLayer(polygonOutlineLayerId);
        if (map.getLayer(polygonFillLayerId)) map.removeLayer(polygonFillLayerId);
        if (map.getSource(S3_SOURCE_ID)) map.removeSource(S3_SOURCE_ID);

        // Adds the raw GeoJSON file to the map as a data source.
        map.addSource(S3_SOURCE_ID, {
          type: "geojson",
          data: geojson,
        });

        // Fills colour for polygon features
        map.addLayer({
          id: polygonFillLayerId,
          type: "fill",
          source: S3_SOURCE_ID,
          filter: ["==", "$type", "Polygon"],
          paint: {
            "fill-color": ["coalesce", ["get", "color"], "#4F46E5"],
            "fill-opacity": 0.3,
          },
        });

        // Outline colour for polygon features
        map.addLayer({
          id: polygonOutlineLayerId,
          type: "line",
          source: S3_SOURCE_ID,
          filter: ["==", "$type", "Polygon"],
          paint: {
            "line-color": "#312E81",
            "line-width": 2,
          },
        });

        // Circle style for point features
        map.addLayer({
          id: pointLayerId,
          type: "circle",
          source: S3_SOURCE_ID,
          filter: ["==", "$type", "Point"],
          paint: {
            "circle-radius": 6,
            "circle-color": ["coalesce", ["get", "color"], "#DC2626"],
            "circle-stroke-color": "#FFFFFF",
            "circle-stroke-width": 2,
          },
        });

        // Keep pins above polygons if already added
        if (map.getLayer(PIN_CIRCLE_LAYER_ID)) {
          map.moveLayer(PIN_CIRCLE_LAYER_ID);
        }
        if (map.getLayer(PIN_LABEL_LAYER_ID)) {
          map.moveLayer(PIN_LABEL_LAYER_ID);
        }

        // Fit the map view to both datasets
        const bounds = computeBoundsFromGeoJson(geojson);
        s3BoundsRef.current = bounds;
        fitMapToBounds(map, bounds, pinBoundsRef.current);
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error("Failed to load GeoJSON data:", error);
        }
      }
    };

    // If the map is loaded, add GeoJSON. Otherwise, wait for load event.
    if (map.loaded()) {
      addGeoJsonToMap();
    } else {
      map.once("load", addGeoJsonToMap);
    }

    // Cleanup for this effect
    return () => {
      abortController.abort();
      map.off("load", addGeoJsonToMap);
    };
  }, [geoJsonUrl]);

  // Adds pin location data from the remote endpoint
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;

    const addPinsToMap = () => {
      if (map.getLayer(PIN_LABEL_LAYER_ID)) map.removeLayer(PIN_LABEL_LAYER_ID);
      if (map.getLayer(PIN_CIRCLE_LAYER_ID)) map.removeLayer(PIN_CIRCLE_LAYER_ID);
      if (map.getSource(PIN_SOURCE_ID)) map.removeSource(PIN_SOURCE_ID);

      map.addSource(PIN_SOURCE_ID, {
        type: "geojson",
        data: pinsGeoJson,
      });

      map.addLayer({
        id: PIN_CIRCLE_LAYER_ID,
        type: "circle",
        source: PIN_SOURCE_ID,
        paint: {
          "circle-radius": 7,
          "circle-color": "#EF4444",
          "circle-stroke-color": "#FFFFFF",
          "circle-stroke-width": 2,
        },
      });

      map.addLayer({
        id: PIN_LABEL_LAYER_ID,
        type: "symbol",
        source: PIN_SOURCE_ID,
        layout: {
          "text-field": ["coalesce", ["get", "name"], ""],
          "text-offset": [0, 1.2],
          "text-size": 14,
          "text-anchor": "top",
        },
        paint: {
          "text-color": "#111827",
          "text-halo-color": "#FFFFFF",
          "text-halo-width": 1,
        },
      });

      // Ensure pins on top
      map.moveLayer(PIN_CIRCLE_LAYER_ID);
      map.moveLayer(PIN_LABEL_LAYER_ID);

      // Fit to both datasets
      pinBoundsRef.current = pinBounds;
      fitMapToBounds(map, s3BoundsRef.current, pinBoundsRef.current);
    };

    if (map.loaded()) {
      addPinsToMap();
    } else {
      map.once("load", addPinsToMap);
    }

    return () => {
      map.off("load", addPinsToMap);

      if (map.getLayer(PIN_LABEL_LAYER_ID)) map.removeLayer(PIN_LABEL_LAYER_ID);
      if (map.getLayer(PIN_CIRCLE_LAYER_ID)) map.removeLayer(PIN_CIRCLE_LAYER_ID);
      if (map.getSource(PIN_SOURCE_ID)) map.removeSource(PIN_SOURCE_ID);
    };
  }, [pinsGeoJson, pinBounds]);

  // This is the actual piece of HTML React puts on the page.
  return <div ref={mapContainerRef} style={{ height, width: "100%" }} />;
}

